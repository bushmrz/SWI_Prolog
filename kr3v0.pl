%1 Построить предикат vz_prost(+X,+Y), проверяющий числа на взаимную
% простоту. (любой числовой алгоритм с применением рекурсии вверх или
% вниз).
%
nod(A, 0, A):-!.
nod(A,0,_):-!,fail.
nod(A,B,C):- Ost is A mod B, nod(B, Ost, C).

vz_prost(X,Y):-nod(X,Y,1).


% 2 Построить предикат max_list(+List), определяющий индекс элемента
% списка, имеющего максимальную сумму чисел, меньших элемента и
% взаимно-простых с ним. Для построения воспользоваться предикатом из
% предыдущей задачи.(Воспользоваться рекурсией вверх или вниз).
% 4 ->  1 3
% 7 -> 1 2 3 4 5 6
% 8 -> 1 3 5 7 -> 16

sum_pv(X,S):-   sum_pv(X,X,S).
sum_pv(_,0,0):-!.
sum_pv(X,Y,S):-
    vz_prost(X,Y),!, Y1 is Y-1,
    sum_pv(X,Y1,S1),S is Y+S1.
sum_pv(X,Y,S):-
    Y1 is Y-1,
    sum_pv(X,Y1,S).


max_list(List):- max_list(List,I,0,0),!, write(I).
max_list([],I,_,I):-!.
max_list([H|T], I, IN, IM) :-
    (   sum_pv(H,S), S<H, IM1 is IN; IM1 is IM),
    IN1 is IN+1, max_list(T,I,IN1,IM1).

